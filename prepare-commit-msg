#! /usr/bin/env python3

#
# Copyright (c) Gustav le Dous
#
# WARNING: Use with caution. Partially made while drunk
#

from pathlib import Path

from subprocess import run, CalledProcessError

from typing import List, Tuple
import sys
import os

commit_hash_length = int(os.environ.get("SUBMODULE_HOOK_HASH_LENGTH", default=8))
max_commits = int(os.environ.get("SUBMODULE_HOOK_MAX_COMMIT_SHOWN", default=12))


def do_git_command_single_line(*args) -> str:
    return do_git_command_multi_line(*args)[0]


def do_git_command_multi_line(*args) -> List[str]:
    process_result = run(["git"] + [str(arg) for arg in args], capture_output=True)
    process_result.check_returncode()
    raw_output = process_result.stdout.decode()
    result = [i.strip() for i in raw_output.splitlines()]
    return result


repo_root = Path(do_git_command_single_line("rev-parse", "--show-toplevel"))


def find_submodules() -> List[Tuple[str, str]]:
    git_modules_file = repo_root / ".gitmodules"
    if not git_modules_file.exists():
        return []

    try:
        config_lines = do_git_command_multi_line("config", "--file", git_modules_file, "--get-regexp", "path")
    except CalledProcessError:
        print("Submodule commit hook could not parse .gitmodules")
        return []

    result = []
    for module in config_lines:
        if not module:
            continue
        config_module, path = module.split(' ')
        module_name = config_module.split('.')[1]
        result.append((module_name, path))
    return result


def find_previous_revision(path: str, compare_commit: str) -> str:
    # git ls-tree HEAD submodule1
    # 160000 commit c2005918d53fa8d63af5d8ce059f3233969b35ea  submodule1
    # NOTE tab before module name                           /\
    raw = do_git_command_single_line("-C", str(repo_root), "ls-tree", compare_commit, path)

    raw = raw[:raw.index('\t')]
    return raw.strip().split(' ')[2]


def find_staged_revision(path: str) -> str:
    # git ls-files -s submodule1
    # 160000 commit c2005918d53fa8d63af5d8ce059f3233969b35ea 0  submodule1

    raw = do_git_command_single_line('-C', str(repo_root), 'ls-files', '-s', path)
    return raw.split(' ')[1]


def format_submodule_staged_commits(module_name: str, module_path: str, compare_commit: str) -> List[str]:
    head = find_previous_revision(module_path, compare_commit)
    staged = find_staged_revision(module_path)

    max_commits_to_extract = max_commits + 1
    commits = do_git_command_multi_line('-C', repo_root / module_path, 'log', '--pretty=oneline', '-n',
                                        max_commits_to_extract,
                                        f"{head}..{staged}")
    if not commits:
        return []
    result = [f"{module_name}:"]
    for line in commits[:max_commits]:
        splitted = line.split(' ')

        # only use specified length for commit-hash
        commit_hash = splitted[0][:commit_hash_length]
        commit_msg = ' '.join(splitted[1:])
        result.append(f'    {commit_hash} {commit_msg}')

    if len(commits) > max_commits:
        # if truncated
        total_commits = do_git_command_single_line('-C', repo_root / module_path, 'rev-list', '--count', f"{head}..{staged}")
        not_shown_commits = int(total_commits) - max_commits
        result.append(f'    ... +{not_shown_commits} more')

    result.append("")
    return result


def generate_changeset_description(compare_commit: str) -> List[str]:
    lines = []

    for module_name, module_path in sorted(find_submodules(), key=lambda x: x[0]):
        lines.extend(format_submodule_staged_commits(module_name, module_path, compare_commit))

    return lines


def inject_submodule_changeset(existing_changeset: List[str], compare_commit: str) -> List[str]:
    to_inject = generate_changeset_description(compare_commit)

    has_changes = bool(to_inject)

    entry_header = "Submodule changes:"
    entry_footer = "End of submodule changes:"

    already_has_entry = entry_header in existing_changeset and entry_footer in existing_changeset
    to_insert = [entry_header, *to_inject, entry_footer]

    header_index, footer_index = -1, -1
    if already_has_entry:
        header_index = existing_changeset.index(entry_header)
        footer_index = existing_changeset.index(entry_footer)

    result = ""

    # 4 cases
    if not has_changes and not already_has_entry:
        # ok!
        result = existing_changeset

    if not has_changes and already_has_entry:
        # remove the changeset
        result = existing_changeset[:header_index] + existing_changeset[footer_index + 1:]

    if has_changes and not already_has_entry:
        # insert at the end

        # Add a newline if necessary
        newlines = []
        if len(existing_changeset) >= 1:
            if existing_changeset[-1]:
                newlines.append("")
                if len(existing_changeset) >= 2 and existing_changeset[-2]:
                    newlines.append("")

        result = existing_changeset + newlines + to_insert

    if has_changes and already_has_entry:
        # replace entry

        result = existing_changeset[:header_index] \
                 + to_insert + existing_changeset[footer_index + 1:]

    # add newline at the end
    if result[-1]:
        result.append("")

    return result


def apply_changes(filename: str, compare_commit: str):
    import os
    print(os.getcwd())

    with open(filename, 'r') as f:
        content = [line.strip() for line in f.readlines()]

    with open(filename, 'w') as f:
        f.writelines(line + os.linesep for line in inject_submodule_changeset(content, compare_commit))


def figure_out_previous_source(argv) -> str:
    if len(argv) < 3:
        return "HEAD"

    # This happens when --amend is provided
    if argv[2] != "commit":
        return "HEAD"

    if len(argv) < 4:
        # Should not happen but whatever
        return "HEAD"

    # The commit before amended commit
    return f"{argv[3]}~1"


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Missing input file")
        sys.exit(0)

    commit_source = figure_out_previous_source(sys.argv)

    apply_changes(sys.argv[1], commit_source)
