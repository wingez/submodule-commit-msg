#! /usr/bin/env python3

#
# Copyright (c) Gustav le Dous
#
# WARNING: Use with caution. Partially made while drunk
#
from dataclasses import dataclass
from pathlib import Path

from subprocess import run, CalledProcessError
from typing import List, Tuple
import sys
import os

commit_hash_length = int(os.environ.get("SUBMODULE_HOOK_HASH_LENGTH", default=8))
max_commits = int(os.environ.get("SUBMODULE_HOOK_MAX_COMMIT_SHOWN", default=12))


def do_git_command_single_line(*args) -> str:
    lines = do_git_command_multi_line(*args)
    if len(lines) > 0:
        return lines[0]
    else:
        return ""


def do_git_command_multi_line(*args) -> List[str]:
    process_result = run(["git"] + [str(arg) for arg in args], capture_output=True)
    process_result.check_returncode()
    raw_output = process_result.stdout.decode()
    result = [i.strip() for i in raw_output.splitlines()]
    return result


repo_root = Path(do_git_command_single_line("rev-parse", "--show-toplevel"))


@dataclass(frozen=True)
class Submodule:
    name: str
    path: str


def find_submodules(modules_path: Path) -> List[Submodule]:
    try:
        config_lines = do_git_command_multi_line("config", "--file", modules_path, "--get-regexp", "path")
    except CalledProcessError:
        return []

    result = []
    for module in config_lines:
        if not module:
            continue
        config_module, path = module.split(' ')
        module_name = config_module.split('.')[1]
        result.append(Submodule(module_name, path))
    return result


def find_previous_and_current_submodules() -> Tuple[List[Submodule], List[Submodule]]:
    tmp_file = repo_root / "submodule_cmd_hook_tmp"
    try:
        with open(tmp_file, mode="wb+") as write_me:
            result = run(["git", "-C", str(repo_root), "show", ":.gitmodules", "--", ], stdout=write_me)
        if result.returncode == 0:
            current_modules = find_submodules(tmp_file)
        else:
            current_modules = []

        with open(tmp_file, mode="wb+") as write_me:
            result = run(["git", "-C", str(repo_root), "show", "HEAD:.gitmodules", ], stdout=write_me)
        if result.returncode == 0:
            previous_modules = find_submodules(tmp_file)
        else:
            previous_modules = []

    finally:
        tmp_file.unlink(missing_ok=True)

    return previous_modules, current_modules


def find_previous_revision(path: str, compare_commit: str) -> str:
    # git ls-tree HEAD submodule1
    # 160000 commit c2005918d53fa8d63af5d8ce059f3233969b35ea  submodule1
    # NOTE tab before module name                           /\
    raw = do_git_command_single_line("-C", str(repo_root), "ls-tree", compare_commit, path)
    raw = raw[:raw.index('\t')]
    return raw.strip().split(' ')[2]


def find_staged_revision(path: str) -> str:
    # git ls-files -s submodule1
    # 160000 commit c2005918d53fa8d63af5d8ce059f3233969b35ea 0  submodule1

    raw = do_git_command_single_line('-C', str(repo_root), 'ls-files', '-s', path)
    return raw.split(' ')[1]


def format_submodule_staged_commits(module_name: str, module_path: str, compare_commit: str) -> List[str]:
    head = find_previous_revision(module_path, compare_commit)
    staged = find_staged_revision(module_path)

    max_commits_to_extract = max_commits + 1
    commits = do_git_command_multi_line('-C', repo_root / module_path, 'log', '--pretty=oneline', '-n',
                                        max_commits_to_extract,
                                        f"{head}..{staged}")
    if not commits:
        return []
    result = [f"{module_name}:"]
    for line in commits[:max_commits]:
        splitted = line.split(' ')

        # only use specified length for commit-hash
        commit_hash = splitted[0][:commit_hash_length]
        commit_msg = ' '.join(splitted[1:])
        result.append(f'    {commit_hash} {commit_msg}')

    if len(commits) > max_commits:
        # if truncated
        total_commits = do_git_command_single_line('-C', repo_root / module_path, 'rev-list', '--count',
                                                   f"{head}..{staged}")
        not_shown_commits = int(total_commits) - max_commits
        result.append(f'    ... +{not_shown_commits} more')

    return result


def generate_changeset_description(compare_commit: str) -> List[str]:
    previous_modules, current_modules = find_previous_and_current_submodules()

    added_modules = set(current_modules).difference(set(previous_modules))
    removed_modules = set(previous_modules).difference(set(current_modules))
    consistent_modules = set(previous_modules).intersection(set(current_modules))

    chunks = []
    for added in added_modules:
        chunks.append([
            added.name + ':',
            "    Added"
        ])

    for removed in removed_modules:
        chunks.append([
            removed.name + ':',
            "    Removed"
        ])

    for submodule in sorted(consistent_modules, key=lambda x: x.name):
        chunks.append(format_submodule_staged_commits(submodule.name, submodule.path, compare_commit))

    lines = []
    for chunk in chunks:
        if chunk:
            lines.extend(chunk)
            lines.append("")

    return lines


def inject_submodule_changeset(existing_changeset: List[str], compare_commit: str, existing_trailers: List[str]) -> \
        List[str]:
    to_inject = generate_changeset_description(compare_commit)

    has_changes = bool(to_inject)

    entry_header = "Submodule changes:"
    entry_footer = "End of submodule changes:"

    already_has_entry = entry_header in existing_changeset and entry_footer in existing_changeset
    to_insert = [entry_header, *to_inject, entry_footer]

    header_index, footer_index = -1, -1
    if already_has_entry:
        header_index = existing_changeset.index(entry_header)
        footer_index = existing_changeset.index(entry_footer)

    # 4 cases
    if not has_changes and not already_has_entry:
        # ok!
        result = existing_changeset

    if not has_changes and already_has_entry:
        # remove the changeset
        result = existing_changeset[:header_index] + existing_changeset[footer_index + 1:]

    if has_changes and not already_has_entry:
        # insert at the end but before any trailers

        index_of_first_trailer = len(existing_changeset)
        for index, line in enumerate(existing_changeset):
            if line in existing_trailers:
                index_of_first_trailer = index
                break

        newlines = []
        if index_of_first_trailer - 1 >= 0:
            if existing_changeset[index_of_first_trailer - 1]:
                newlines.append("")

        result = existing_changeset.copy()

        result[index_of_first_trailer:index_of_first_trailer] = newlines + to_insert + [""]

    if has_changes and already_has_entry:
        # replace entry

        result = existing_changeset[:header_index] \
                 + to_insert + existing_changeset[footer_index + 1:]

    # add newline at the end
    if result[-1]:
        result.append("")

    return result


def apply_changes(filename: str, compare_commit: str):
    existing_trailers = do_git_command_multi_line("interpret-trailers", "--parse", filename)

    with open(filename, 'r') as f:
        content = [line.strip() for line in f.readlines()]

    with open(filename, 'w') as f:
        f.writelines(
            line + os.linesep for line in inject_submodule_changeset(content, compare_commit, existing_trailers))


def figure_out_previous_source(argv) -> str:
    if len(argv) < 3:
        return "HEAD"

    # This happens when --amend is provided
    if argv[2] != "commit":
        return "HEAD"

    if len(argv) < 4:
        # Should not happen but whatever
        return "HEAD"

    # The commit before amended commit
    return f"{argv[3]}~1"


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Missing input file")
        sys.exit(0)

    commit_source = figure_out_previous_source(sys.argv)

    apply_changes(sys.argv[1], commit_source)
